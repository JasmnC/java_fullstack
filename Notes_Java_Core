Singleton
- to ensure only one once
Lazy loading
//lazy loading
public class Singleton{
    private static Singleton instance;
    private Singleton(){
    }
    public static Singleton getInstance(){
        if (instance==null){
            instance=new Singleton;;
        }
        Return instance
    }
}
Eager loading
//  private static *final* EagerInitializedSingleton instance = new EagerInitializedSingleton();

Access Modifier: public, private, default*, protected*考點
default is the default, gives package level accessibility for field, method, class
protected=default+sub-class(gives parent/child access)
private is only available in class

What is Class?
Class is a template, basicallt a blue print
* object/instance vs template ->objects should declare by new keyword
* other templates include Interface, Abstract Class, (not a template but a annotation) enum
- Interface vs abtract class
  multiple <-> one 

Static keyword
It’s a method
Access elements from template
JVM calls it, and only executed once when loading, compile before run
* JVM’s structure –> contains stack, heap, PC register, method area, native method area
- heap vs stack: 
- only inner class can be static
Static are sorted in method area

Final keyword
It’s a modifier, can be apply on field, method, class
For field: the value can only be assign once, means reference cannot be change, but the object itself can still be update
For method: can not be override by sub-class
For class: can not be extend, often used for Immutable class
* Immutable: 
declare final
declare private
only use getters, no setters
actively do deep copy

Finally vs Finalize
- try-catch-finally
- finalize() for garbage collection

Override vs Overload
both concepts of polymorphism
Run time <--> compile time
In between classes(parent child) <--> multiple same name +different parameter methods within the same class


Factory Design Pattern
Scenario e-commerce is using 2 payment method, say paypal and cc
- any access modifier for interface is public
- avoid using double or float, because they cause inaccuracy(accuracy depends on if 1st bit sign or not)

Double vs double:
double is primitive, Double is referenced data type 
* 8 primitives(small->big)(numeric) byte, short, int, long, float, double, (non-numeric) boolean, char
Since primitive types are not an object, java uses wrapper class and autoboxing(Double) to make primitive behave like objects, to achieve OOP
- primitive data types vs reference 
  sort in stack <-> reference stor in heap and object sort in stack

Some string examples:
// String
-> Constant String pool -> heap
// String VS StringBuilder vs StringBuffer ->
// String
comparison -> equals vs
* String s1 = "a";
* String s2 = "a";
* String s3 = new String("a");
* String s4 = new String("a");
* System.out.println(s1.equals(s2));
* System.out.println(s3.equals(s4));
* System.out.println(s1==s2);
*System.out.printin（53==54）



Payment Code
interface Payment(){
  void Pay(Dicimal amount);
}

class PayPalPayment implements Payment{
    public void pay(double money){
        System.out.println("Pay pal");
    }
}

class CreditCardPayment implements Payment{
    public void pay(double money){
        System.out.println("credit card payment");
    }
}

class PaymentFactory {
    public static Payment createPayment(String type)  {
        switch(type.toLowerCase()) {
            case "paypal": return new PayPalPayment();
            case "creditcard": return new CreditCardPayment();
            default:
                try {
                    throw new IllegalAccessException("unknown type" + type);
                } catch (IllegalAccessException e) {
                    System.out.println(e.getMessage());
                    // logger.debug();
                    // loger.info();
                } finally {

                }
        }
    }
}

Exception Handling
Throw vs Throws
Use in the function <-> use in the function signature
“try-catch-finally”
- throwable interface for exception customization
Types of exceptions: runtime time(use keyword to handle it, or else it will throw error ), compile time(have to use try-catch-finally or program will not run at all)
- extend exception parts
All errors came from throwable class unless handled by try-catch
Exceptions vs Error
Can be handle in code <->can not be handle in code(ex: StackOverFlow or OutOfMemory)
- exception status code?

Collections: Lists
ArrayList vs LinkedList
access by index <-> Had to iterate through
backed by dynamic arrays <-> when there's a lot of inserts
- (lagacy) vectors are discontinues because arraylist is thread safe
- stack

Collections: Queue
priority queue: heap by default

- comparible vs comparitor
compare on itself<->based on lambda expression

Collections: Set
HashMap vs HashSets

OOP
Inheritance -> interface + abstract class +final
Encapsulation -> access modifier
Polymorphism -> override vs overload
Abstraction ->interface + abstract class

SOLID
They are Achrinom for principles
S: single responsibility
O: open/closed
L: Lonskov principle
D: dependency injection

Multi-threading and Concurrency
program vs process vs threads
static code <-> execution of program <-> a execution rutine
- one process is going to do 1 task and 1 task only
- in between process, it's gerunteed that memory was isolated (cannot be share)
* Java is portable language, compile once(saved the compiled code on memory) and run on any machine
  .Class files(byte files)-> Class Loader -> Memory Area (RAM)
* concurrent programming vs in-parallel program
  concurrent: even when we just have 1 thread, we can switch between different program
Ways to create threads:
1. Thread Class
2. Runnable Interface
3. Callable Interface
4. Thread Pool (technically web-based development, this is only thing you should use)

history of jdk
jdk7
jdk8 -> 2018, widly used but buggy, more stable ver compare to previous-> Spring framework booming
 jdk11 -> released "flight recorder", free version
jdk17 -> Spring6/Springboot 3.0
 * recent 3-5 years a lot directly migrate from 8->17 and/or 8->11->17
 jdk19 -> virtual thread -> Loom project
jdk21 -> virtual thread (normal object)
* we DON'T use latest version

Lifecycle (status) of threads: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITEING, TERMINATED

public class Day5 {
    public static void main(String[] args){
        new MyThread().start();
//        new MyThread().run();
        System.out.println("main thread");

        ExecutorService executorService = Executors.newCachedThreadPool();
    }
}

class MyThread extends Thread {
    public void run() {
        System.out.println("my thread");
    }
}

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("my thread");
    }
}

Thread Safty
concerns: 1. hardware resources limitations;
         2. Thread safety -> concurrency issue -> read/write issue -> problem when one thread read the other thread write and the same time
(these are 2 different things)
* threads don't share memory(resource) together
* access the same resource is not a issue if they don't modify anything on that thread
ex: too many request -> concurrency issue
* jvm structure
* you need a thread to run Runnable
*  *     MyRunnableTask task = new MyRunnableTask();    -> .java -> .class -> (i) creation of object
*  *                                                                          (ii) find a space in heap
*  *                                                                          (iii) assign reference to object
