Spring framework
1. A: AOP
  - aspect oriented programming
  - What: Separates cross-cutting concerns (logging, security, transactions).(use case)
    Why: Keep main logic clean; reusable aspects.
    How: Uses **proxies** + **advice** around methods.
  - @Aspect: you can have different aspect doing different things, within the aspects, you can define:
            -> logic(what I want to do),
            (when) @Before(@annotation(com.example.annotation.Cachable)), @After, @AfterReturning, @AfterThrowing, @Around
            -> @Pointcut("execution(*com.example.Service.UserService.*(...))")
                public void myPointCutExecution(){}
  * this is quite practical, make sure to know how to do it, what are the annotations you use, where did you use the AOP
  - Join Point → where advice applies (method call)
  - Advice → code to run (before/after/around)
  - Pointcut → expression matching join points
  - Proxy → wrapper created by Spring to weave aspect logic

2. I: IOC
  - Inversion of Control
  - What: Framework controls object creation & wiring instead of manual `new`.
    Why: Decouples components → easier testing, maintainability.
    How: Spring container creates & injects beans defined via XML, annotations, or Java config.
  - Dependency Injection (3 styles)
    1. Constructor Injection -> via constructor args. Immutable, good for required deps.
    2. Setter Injection -> via setters. Optional deps, but mutable.
    3. Field Injection -> via `@Autowired` on field. Simple but hard to test (no immutability).

  - Bean scope:
    * `singleton` (default) –> one per container
    * `prototype` –> new each request
    * `request`, `session`, `application` –> for web contexts

  - Spring Container:
    * `BeanFactory` (basic)
    * `ApplicationContext` (advanced; adds event, i18n, etc.)

  - Circular Dependency:
    * Happens when A -> B -> A.
    * Spring resolves via **setter/field injection**, but fails with **constructor injection**.



What is maven?
  A auto building tool.
  pain-point to solve: 1. dependency management -> under external libraries it's not just download jdk-jar files and done, you also have to import it 100 times
                       1.5. Volurnbility detection -> since it takes control of jdk-jars, maven helps keep track of the known bugs(mvnrepository.com)/
                         download from central library to avoid melicious malware
                       2. package and scope management
                         -> manditory in pom.xml: groupId, artifactId, version
                         -> have a universal place to save all package
                       3. Life cycle management -> see the target folder, if you need a jar file to deploy to prod. 
                                                  * click the package, it's going to go through the target folder, clean>reload>verify....see lifecycle it's in the exact order
  * command+',' to access setting in IntelliJ, find maven under Settings > Build, Execution, Deployment > Build Tools > Maven
  - repos
    local vs central
    sort on machine at ~/.m2/repository by default <-> https://repo.maven.apache.org/maven2
  - setting.xml
    -> set up proxy, servers, mirror, profiles, reporitory
  - pom.xml(project object model)
    -> dependencies, plug-in, build settings
    *is the main config file for maven project
    -> dependency coordinates: groupId, artifacts, version

  - mavean Lifecycle
    validate (check project stucture), compile(compile source code), test(run tests), package(build JAR), install (copy to local repo), deploy(publish to remote repo)
    *can find on the right hand side panel when we click on maven
