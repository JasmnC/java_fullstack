Transactions
- a group of query that execute together

Optimistic lock vs pestimistic lock
- optemistic: we don't assume there's any error, we allow concurrency assume there's no conflicts
  - so how do we maintain thread safe?
  - we have @Version spring-data-jpa will check / track -> but this is manual
  - if things goes right, it's going to faster
  - in JDBC you can also deal with and we use try-catch-finally block
* implementation depends on what tool you chose, trade off pros and cons

Distributed = when multiple microservices or DBs are involved.
Distributed transaction concerns: when dif
Approaches:
1. Distributed Lock (e.g., Redis-based Redlock)
    One service holds a short lock while updating.
2. Two-Phase Commit (2PC)
  Coordinator asks all participants(microservices) to “prepare” → “commit”. (if prepare phase fail, they rollback)
  when we say "ready", what does that mean? -> check execution conditions
  who's going to check? -> we have a centralized "coordinator"(master)(our springboot in this case) and each microservice is like worker
  trade-off -> it's against microservice(we're tieing them back together), strong atomicy
  * single point failuare, lower avalilbility
3. Saga Pattern
  Breaks big transaction into stages, each with a compensating action.
  two styles: choreography, orchestration
  choreography -> take away coordinator, each of the worker execute on their own(each have to define rollback)-> chain flow
  orchestration -> still have a coordinator
  * depends on how complicate it is, 3-5 steps choreography makes more sence, 30 steps choreography
  * if you need each step monitor, must use orchestration
  * higher consistency, higher avalilbility

SQL optimization
1. Identify first!!
execution plan, explain statement
2. Indexing: cluster index, primary key



