Transactions
- a group of query that execute together

Optimistic lock vs pestimistic lock
- optemistic: we don't assume there's any error, we allow concurrency assume there's no conflicts
  - so how do we maintain thread safe?
  - we have @Version spring-data-jpa will check / track -> but this is manual
  - if things goes right, it's going to faster
  - in JDBC you can also deal with and we use try-catch-finally block
* implementation depends on what tool you chose, trade off pros and cons

Distributed = when multiple microservices or DBs are involved.
Distributed transaction concerns: when dif
Approaches:
1. Distributed Lock (e.g., Redis-based Redlock)
    One service holds a short lock while updating.
2. Two-Phase Commit (2PC)
  Coordinator asks all participants(microservices) to “prepare” → “commit”. (if prepare phase fail, they rollback)
  when we say "ready", what does that mean? -> check execution conditions
  who's going to check? -> we have a centralized "coordinator"(master)(our springboot in this case) and each microservice is like worker
  Atomic, simple, but slow, used in financial systems.
3. Saga Pattern
  Breaks big transaction into steps, each with a compensating action.
  Preferred for microservices.
