1. Source Stage (SCM Integration)
  - Purpose: pull the latest code and ensure that your pipeline automatically reacts to changes in the repository.
When to Use
Use this stage whenever your application source code is stored in Git-based platforms such as GitHub, GitLab, or Bitbucket. It is essential for any automated development workflow.
Tech Stack and Usage
SCM: Git, GitHub, GitLab, Bitbucket
Triggering: Webhooks, scheduled builds
Jenkinsfile: Pipeline definitions written in Groovy
2. Build Stage
  - Purpose: compiles the application, installs dependencies, and prepares the codebase for testing and packaging.
When to Use
Use this stage for any project requiring compilation or dependency resolution. It is required for back-end services, microservices, or applications with build steps.
Tech Stack and Usage
Java: Maven, Gradle
Python: virtualenv, pip
JavaScript: npm, yarn
Container-based: Dockerfile builds
3. Test Stage
Purpose
This stage ensures code correctness, quality, and compliance before moving into deployment.
When to Use
Use this stage whenever your application has automated tests, static analysis, linting rules, or compliance checks. It is important for production-quality software.
Tech Stack and Usage
Testing frameworks: JUnit, PyTest, Jest
Static analysis: SonarQube, ESLint, Pylint, Checkstyle
Security scanning: Trivy, OWASP Dependency-Check
4. Artifact Packaging Stage
Purpose
This stage packages the application into a deployable format, such as binary artifacts or container images. It also stores these artifacts in a registry for later use.
When to Use
Use this stage when you need reproducible builds or when deploying across multiple environments. Critical for microservices, cloud-native applications, and containerized deployments.
Tech Stack and Usage
Artifact packaging: JAR/WAR files, ZIP, wheel
Container images: Docker, Buildah
Artifact registries: Docker Hub, AWS ECR, GCP Artifact Registry, Nexus, Artifactory
5. Deployment Stages
Purpose
These stages deliver the application into specific environments such as development, testing, staging, and production.
Use Case: Dev Deployment
Used for fast, iterative deployments after initial build and testing. Suitable for developer validation and integration testing.
Use Case: QA/Staging Deployment
Used when verifying application functionality in a controlled environment. Supports user acceptance testing, regression testing, and pre-production checks.
Use Case: Production Deployment
Used when releasing stable builds to end users. Often requires approval, rollback strategies, and monitoring.
Tech Stack and Usage
Deployment scripts: Bash, Python, Ansible
Container orchestration: Kubernetes, Helm, ArgoCD
Traditional servers: SSH-based deployment, systemd
Cloud platforms: AWS ECS/EKS, Azure AKS, Google GKE
6. Monitoring and Post-Deployment Stage
Purpose
Monitors application health, validates that deployments are functioning correctly, and sends notifications about build results.
When to Use
Use this stage for any production deployment, or when you require operational visibility. Also used for automated health checks after deployment.
Tech Stack and Usage
Health checks: curl, API endpoints
Monitoring platforms: Prometheus, Grafana, Datadog, New Relic
Notification tools: Slack, Email, Microsoft Teams
* Pipeline Governance and Controls
Purpose
Provides quality gates, approval mechanisms, and policies to control how code moves across environments.
When to Use
Use governance controls when handling sensitive or high-impact deployments such as financial services, healthcare, or large distributed teams.
Tech Stack and Usage
Manual approvals: Jenkins input steps
Access control: Role-based permissions in Jenkins
Automated gates: SonarQube Quality Gates, security scans
