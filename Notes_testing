
1. Source Stage (SCM Integration)

   * Purpose: Pulls the latest code and ensures the pipeline automatically reacts to repository changes.
   * When to Use: When source code is stored in Git-based platforms such as GitHub, GitLab, or Bitbucket.
   * Tech Stacks:

     * SCM: Git, GitHub, GitLab, Bitbucket
     * Triggering: Webhooks, scheduled builds
   * Jenkinsfile: Pipeline definitions written in Groovy

2. Build Stage

   * Purpose: Compiles the application, installs dependencies, and prepares the codebase for testing and packaging.
   * When to Use: When working on any project that requires compilation or dependency resolution (Java, Python, Node, etc.).
   * Tech Stacks:

     * Build Tools: Maven, Gradle, npm, yarn, pip
     * Container Build: Dockerfile, Buildah
   * Jenkinsfile: Defines build steps using shell commands or reusable shared libraries

3. Test Stage

   * Purpose: Ensures code correctness, reliability, and quality before deployment.
   * When to Use: When the application has unit tests, integration tests, or static analysis requirements.
   * Tech Stacks:

     * Test Frameworks: JUnit, PyTest, Jest
     * Static Analysis: SonarQube, ESLint, Pylint, Checkstyle
     * Security Scanning: OWASP Dependency-Check, Trivy
   * Jenkinsfile: Includes test execution, results publishing, and quality gate logic

4. Artifact Packaging Stage

   * Purpose: Packages the application into a deployable format such as binaries or container images.
   * When to Use: When you need a consistent build output for deploying across multiple environments.
   * Tech Stacks:

     * Packaging Formats: JAR/WAR, Python wheel, ZIP archives
     * Containerization: Docker, Buildah
     * Artifact Registries: Docker Hub, AWS ECR, GCP Artifact Registry, Nexus, Artifactory
   * Jenkinsfile: Handles packaging and pushing artifacts to registries

5. Deployment to Development Environment

   * Purpose: Allows developers to validate integrations and basic functionality after building and testing.
   * When to Use: During frequent iteration cycles or feature development.
   * Tech Stacks:

     * Deployment Scripts: Bash, Python, Ansible
     * Platforms: Docker Compose, Kubernetes (dev namespaces), local servers
   * Jenkinsfile: Executes automated deployment scripts for the dev environment

6. Deployment to QA / Staging Environment

   * Purpose: Enables testing teams to validate the application in a more controlled, production-like environment.
   * When to Use: Before production release, for UAT, regression testing, and integration testing.
   * Tech Stacks:

     * Orchestration: Kubernetes, Helm, ArgoCD
     * Testing Tools: Selenium, Postman, JMeter
   * Jenkinsfile: Adds steps for environment-specific deployment and running extended test suites

7. Deployment to Production Environment

   * Purpose: Releases stable builds to end users with safety controls and governance.
   * When to Use: When the application is ready for customer consumption or business operations.
   * Tech Stacks:

     * Infrastructure: AWS ECS/EKS, Azure AKS, Google GKE, on-prem servers
     * Release Strategies: Blue-green deployment, rolling update, canary release
   * Jenkinsfile: Includes manual approvals, rollback handling, and production-specific deployment steps

8. Post-Deployment and Monitoring Stage

   * Purpose: Validates deployment health and provides visibility into system performance.
   * When to Use: After any deployment, especially in staging and production.
   * Tech Stacks:

     * Monitoring: Prometheus, Grafana, Datadog, New Relic
     * Logging: ELK Stack, Loki
     * Notifications: Slack, Email, Microsoft Teams
   * Jenkinsfile: Adds health checks, reporting, and notifications

9. Governance, Approvals, and Quality Controls

   * Purpose: Adds safety, compliance, and policy enforcement across environments.
   * When to Use: For sensitive, regulated, or high-risk applications, or when multiple teams are involved.
   * Tech Stacks:

     * Quality Gates: SonarQube, SAST tools, vulnerability scanners
     * Access Control: Jenkins RBAC, credential bindings
   * Jenkinsfile: Uses approval gates, conditional steps, and automated policy checks
